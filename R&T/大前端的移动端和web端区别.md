# 大前端的移动端和 web 端区别

## 前端发展史

### 阶段一：刀耕火种

十多年前没有移动端的概念，手机页面上主要以文字排版位置，前端框架主要使用 jQuery，Zepto.js 减少体积

### 阶段二： 工程化

2011~2014 模块化思想占主导，出现了各种模块化协议规范，当时比较流行的模块化协议就是 AMD(RequireJS)、CMD(Seajs 为代表)、KMD(Kissy 为代表)，AMD 在国外比较流行， 但渐渐也被后来出现的 CommonJS 规范削弱了气势

### 阶段三：移动化

随着 3G，4G 的发展，ios 和 android 手机普及，业务主战场从 pc 转移到移动端。移动端的 HTML5 协议支持不完善，前端的生产配套不全，Android 的屏幕碎片化，所以那个时候的前端开发移动端页面适配的痛苦要远远超过 PC 时代。

### 阶段四：框架化

随着前端社区出现一个个前端框架（如 angular，react，vue，react-native。weex），前端有了终端底层开发组，开始构思前端页面在终端上的性能和用户体验

### 阶段五：垂直化

随着大屏幕手机逐渐变成了主流，移动端的需求开始爆发，前端的领域也随着 这种趋势逐渐细分，按照场景可以简单分为移动(无线)前端开发和中后台前端开发，移动前端开发面向的是消费者端的 Web 与 轻 App 业务场景，中后台前端则是面向企业 ERP、CRM 、OA 等偏后的业务场景，如商家后台等系统

## 移动前端:混合技术的前世今生

`从技术的表现形式思考，本质上客户端开发与前端开发都是终端技术，它的特点是直接面向 用户 UI 编程`

同是 UI 编程，我们面对的痛点是什么?

### 传统 Web 前端技术的技术局限性

1. 资源加载：效率比 native 低，资源都通过异步请求服务器获取
2. 渲染机制：单线程，执行复杂 js 逻辑时导致的卡顿通常会 阻塞 UI
3. 页面切换：依赖于浏览 器 Shell 提供的能力，在页面切换的时候会反复加载
4. API 能力：使用 W3C 标准定义的功能，而且考虑到终端碎片化的问题，这些接口往往不能直接使用
5. 交互性能:浏览器的实时交互性能体验差，在复杂交互场景中大规模的重排限制了 UI 帧率，这种限制在中低端移动设备中尤为严重
6. 脚本语言：动态解析执行:JS 是一门 JIT 语言，也就是需要动态解析执行，对比预先 编译机器码的 AOT 语言的执行性能就差得多了

### 传统客户端技术的局限性

1. 动态性:客户端开发通常是有固定的版本发布计划，而且受制于 Apple 的 App Store 审核规则，版本发布的不确定性还会受到政策影响，Android 在国内的渠道众多， 每次发版都要反复检查渠道，一旦发现线上问题需要依赖再次发版，容错成本非常高， 这也大大增加了对业务的局限性。
2. 开发成本:客户端的开发成本高，然而生态还不如 Web 丰富，npm 社区的几万开源包，加上更活跃的开发者社区，导致对企业来讲客户端的研发成本是高于 Web 开发的。
3. 跨端一致性:传统客户端开发一套业务，是需要实现 Android + iOS 两套代码的，而 且由于 Android 和 iOS 的操作系统能力差异，同样的需求往往会用不同的视觉和交 互来实现，这也导致了业务成本居高不下。

对比分析以上的 web 前端与原生开发的局限性，也就出现下面的混合式的前端开发

### 混合式前端开发

#### 混合开发为什么兴起

1. 随着 iOS + Android 确立了移动操作系统的统治地位，前端开发者也在寻找使用操作系统提供的能力进行业务开发的模式。
2. Web 的开发方式远比 iOS 和 Android 更加方便和高效，Web 上层出不穷的各种库和框架也远比 Android 和 iOS 的各种库和框架方便的多。
3. Web 上我们可以方便的使用各种前端框架，及时预览效果(想想大型 Android/ iOS 工程的编译时间)

#### 混合开发的三个阶段

##### 阶段一:JSBridge

在这个阶段，主要还是以 WebView 为主，并配合 JSBridge 提供了 Naive 与 JS 之间的通信链路，基于这个通信基础，Native 可以暴露出一些标准服务 API 提供给 JS 调用，同 样的 JS 也可以以此封装一些基础 API 给 Native 调用。前端开发者使用传统 JS + HTML + CSS 进行页面的开发，并且调用 JSBridge API 驱动客户端能力。在这个 阶段，Apache Cordova 是业内的佼佼者，大多互联网公司内部也有自己的 JSBridge 框架实现，可以说 JSBridge 第一次给了前端开发者调用 Native 的能力。
但是 JSBridge 方案的主要缺点在于性能方面及高级组件扩展能力缺失，流畅性始终无法与 Native 媲美。

##### 阶段二:原生 UI

React Native/Weex 利用 JS 引擎来调用 Native 端的组件，从而实现相应的功能。 React Native 和 Weex 都允许前端开发者使用 JS 进行业务逻辑开发，使用 VDOM 来描述文档结构，并配合 CSS 的子集来定制样式，样式和模板分离。
Weex 体系中，JS 的执行在 JS Thread，Layout 执行在独立的 Layout Thread，渲染执行 在系统的 MainThread ，三个线程相互独立，并行执行。
在 WebView 的体系中 JS 的执行、 Layout 、 Paint 都在 MainThread ，相互影响，在 进行复杂任务时会导致界面卡顿。
这种方案的优势在于最大化的复用前端的生态和 Native 的生态体系。

原生 UI 优化了哪些问题？

1. W3C 作为开放的技术标准，历史悠久，包袱多，显著拖慢了浏览器的性能。
2. WebView 渲染引擎设计的上的缺陷，渲染流水线非常长，导致浏览器对合成器动画和
   非合成器动画区别对待，非合成动画性能不好。
3. 单线程模型，无法发挥现代硬件架构特别是 ARM 架构多核心的性能。
4. 异步光栅化的设计，在进行长列表滚动时，不可避免出现白屏的现象。

##### 阶段三:自绘引擎

所谓自绘引擎，就是不依赖操作系统提供的布局、原生组件能力，直接调用 GPU 或者底层 抽象层进行绘制的渲染引擎。

2018 年 Flutter 诞生，通过 Dart 语言构建一套跨平台的开发组件，所有组件基于 Skia 引 擎自绘，在性能上和 Native 平台的 View 相媲美，同时解决了上一代架构难以解决的双端一致性等问题，但是 Flutter 本身是缺乏动态更新特性的，社区上也有一些项目在探索 Flutter 的动态化特性

## 参考文档

[2020 技术人的百宝黑皮书](https://tao-tech.oss-cn-shanghai.aliyuncs.com/The%20Complete%20Works%20of%20Tao%20Technology%202020.pdf)
