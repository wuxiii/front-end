## 防抖

```js
function debounce(fn, wait, immediate) {
  let timeout
  let firstCall
  return function() {
    if (timeout) {
      clearTimeout(timeout)
    }
    if (immediate) {
      if (!firstCall) {
        firstCall = true
        fn.apply(this, arguments)
      }
    }
    timeout = setTimeout(() => {
      fn.apply(this, arguments)
    }, wait)
  }
}
```

## 节流

```js
function throttle(fn, wait) {
  let lastTime = 0
  return function() {
    let now = Date.now()
    if (lastTime + wait < now) {
      lastTime = now
      fn.apply(this, arguments)
    }
  }
}

function throttle(fn, wait) {
  let canRun = true // 通过闭包保存一个标记
  return function() {
    if (!canRun) return // 在函数开头判断标记是否为true，不为true则return
    canRun = false // 立即设置为false
    setTimeout(() => {
      // 将外部传入的函数的执行放在setTimeout中
      fn.apply(this, arguments)
      // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
      canRun = true
    }, wait)
  }
}
```
