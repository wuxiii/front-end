# 垃圾回收

## GC 算法

### GC 里的垃圾是什么

程序中不在需要使用的对象

### GC 算法是什么

> - GC 是一种机制，垃圾回收器完成的具体的工作
> - 工作的内容就是查找垃圾释放空间回收空间
> - 算法就是工作时查找和回收所遵循的规则

### 常见的 GC 算法

> - 计数引用
> - 标记清除
> - 标记整理
> - 分代回收

### 引用计数算法

#### 核心思想

设置引用数，判断当前引用数是否为 0，如果为 0 立刻回收

#### 优点

- 最大限度减少程序的暂停
- 发现垃圾时立即回收

#### 缺点

- 无法回收循环引用的对象
- 时间开销大

### 标记清除算法

#### 核心思想

分标记和清除两个阶段完成。遍历所有的对象找标记活动对象，遍历所有对象清除没有标记的对象，回收相应的空间

#### 优点

- 可解决无法回收循环引用的对象

#### 缺点

- 造成空间碎片化
- 不能立即回收

### 标记整理算法

#### 优点

- 解决标记清除算法造成空间碎片化的问题

## V8 垃圾回收策略

分代回收思想，将内存分为新生代，老生代，针对不同对象采取不同的垃圾回收算法
新生代指的是存活时间比较短的对象

### V8 中常用的 GC 算法

- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

## 1,引用计数的工作原理和优缺点

工作原理

> 通过一个引用计数器来维护当前对象的引用数，从而判断该对象的引用数值是否为零，来决定它是不是一个垃圾对象，当这个数值为零的时候 GC 算法就开始工作，将其所在的一个对象空间进行回收和释放再使用。

优点

- 发现垃圾时立即回收（一旦引用数值为 0）
- 最大限度减少程序的暂停

缺点

- 无法回收循环引用的对象
- 时间开销大（一直监听着对象的引用数值的变化）

## 2，标记整理算法的工作流程

分为标记和清除两个阶段：首先标记出所有的需要回收的对象，在标记完成以后统一回收所有被标记的对象

## 3，描述 V8 中新生代存储区垃圾回收的流程

在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。

结合 es6 新语法，用最简单的方法找出数组中最小的值

## 4,描述增量标记算法在何时使用及工作原理

增量式回收适合那些相对更重视缩短最大暂停时间而不是最大吞吐量的应用程序

将 GC 中的对象安装各自的情况分为三种，白色（还未搜索过）   灰色（正在搜索） 黑色（搜索完成）

GC 运行前所有的对象都是白色，灰色对象依次从栈中取出，其子对象也会被涂成灰色，当所有的子对象变成灰色时，该对象就会被涂成黑色，当 GC 运行结束，所有的活动对象全部变成黑色，垃圾则为白色

a，根查找阶段  b 标记阶段  c 清除阶段

根查找阶段只在 GC 运行时执行一次，标记会分段进行，操作一定次数后就暂停标记，执行 mutator

清除阶段同标记阶段是增量进行的（incremental_gc()）

标记阶段又会出现标记遗漏的情况，可以用写入屏障来解决，就是在引用白色对象的时候，同时将其涂成灰色对象

分配：如果分块的总量小于一定的值，就执行 GC

停止型 GC 是在分块完全枯竭的情况下才进行的
pickup_trunc()用于搜索空闲链表
